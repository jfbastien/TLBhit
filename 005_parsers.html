<!-- DO NOT EDIT -- episode notes autogenerated by TLBHit's render.py -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <title>TLB hit üí• Episode 5: parsers</title>
    <style>
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 100; src: local('Alegreya Sans Thin'), local('AlegreyaSans-Thin'), url('./fonts/AlegreyaSans-Thin.woff2') format('woff2'), url('./fonts/AlegreyaSans-Thin.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 300; src: local('Alegreya Sans Light'), local('AlegreyaSans-Light'), url('./fonts/AlegreyaSans-Light.woff2') format('woff2'), url('./fonts/AlegreyaSans-Light.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: italic; font-weight: 300; src: local('Alegreya Sans Light Italic'), local('AlegreyaSans-LightItalic'), url('./fonts/AlegreyaSans-LightItalic.woff2') format('woff2'), url('./fonts/AlegreyaSans-LightItalic.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 400; src: local('Alegreya Sans Regular'), local('AlegreyaSans-Regular'), url('./fonts/AlegreyaSans-Regular.woff2') format('woff2'), url('./fonts/AlegreyaSans-Regular.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 300; src: local('Alegreya Sans SC Light'), local('AlegreyaSansSC-Light'), url('../fonts/AlegreyaSansSC-Light.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-Light.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 400; src: local('Alegreya Sans SC Regular'), local('AlegreyaSansSC-Regular'), url('../fonts/AlegreyaSansSC-Regular.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-Regular.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 800; src: local('Alegreya Sans SC ExtraBold'), local('AlegreyaSansSC-ExtraBold'), url('../fonts/AlegreyaSansSC-ExtraBold.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-ExtraBold.woff') format('woff'); font-display: fallback; }

      body { font-family: "Alegreya Sans", Arial, Helvetica, sans-serif; font-weight: 300; }
      header { max-width: 50em; margin: 0 auto; padding: 0 1em; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; }
      header h1 { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 800; margin-bottom: 0; display: flex; flex-direction: column; }
      header h1 a { text-decoration: none; }
      header div { display: flex; flex-direction: column; margin: 1em 0 0 0; }
      header p { margin: 0; text-align: right; }
      header p:first-child { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 300; }
      h2 { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 400; }
      main { max-width: 50em; margin: 0 auto; padding: 0 1em; }
      article { padding: 1em 0; }
      ul { list-style-type: circle; }
      .grid .entry { padding: 1em 0 1em 0; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; }
      .grid h3 { margin: 0; font-weight: 400; }
      .grid .entry .where { display: flex; flex-direction: column; flex-basis: 8em; }
      .grid p, .grid ul { margin: 0; }
      .grid ul { padding: 0 0 0 1em; }
      .grid .where p { font-weight: 100; }
      .grid .entry .what { display: flex; flex-direction: column; flex-basis: 30em; }
      .grid .short { padding: 0.2em 0 0.2em 0; }
      .grid .short .where { display: flex; flex-direction: row; }
      .grid .short .where h3, .grid .short .where p { width: 5em; }

      @media (prefers-color-scheme: dark) {
          body { background-color: #121212; color: white; }
          a:link { color: #bb86fc; }
          a:visited { color: #3700b3; }
      }

      .podcast-audio { width: 100%; }
      .playback-rate-controls ul { margin: 0; padding: 0; list-style: none; text-align: center; }
      .playback-rate-controls li { display: inline; }
      .playback-rate-controls li:not(:last-of-type)::after { content: " | "; }
      .playback-rate-controls ul li a { text-shadow: none; }
    </style>
  </head>
  <body>
    <header>
      <h1><a href='index.html'>TLB hit üí•</a></h1>
      <div>
      <p>A podcast about systems &amp; compilers</p>
      <p>üê¶ <a href="https://twitter.com/TLBhit">@TLBhit</a></p>
      <p>üêò <a rel="me" href="https://hachyderm.io/@TLBhit">hachyderm.io/@TLBhit</a></p>
      <p>üéô <a href="https://tlbh.it/feed.xml">RSS</a></p>
      <p>üçé <a href="https://podcasts.apple.com/us/podcast/tlb-hit/id1538369465">Apple podcast</a></p>
      </div>
    </header>
    <main>
<h1>Parsers Podcast Notes</h1>
<h2>[00:00] Horrible Winter Holiday / Valentine's Day Cold Intro</h2>
<ul>
<li>Warm and fuzzy... and <strong>parse-y</strong>... time of year</li>
<li>Today just going to talk about parsers not fuzzers, but JF likes parse-ley and other assorted rabbit foods</li>
</ul>
<h2>[00:13] Disclaimer</h2>
<h2>[00:35] On Parsers</h2>
<ul>
<li>Talking mostly about our practical experience with parsers</li>
<li>Addressing parsing field as a whole is difficult because it's both theoretically nuanced and large (c.f. a whole Theory of Computation class in school)</li>
<li>One of the criticisms you often hear about original edition of The Dragon Book is that it was frontloaded with a lot of theoretical parser content which tripped many folks up in &quot;intro to compilers&quot; class</li>
<li>A lot of that book was on syntax directed code generation as a backend flow [whereby you parse into an AST, and then largely just walk that AST to generate code directly corresponding to the AST structure as you're walking it, i.e. parse-then-emit-pass-style]<ul>
<li>Understandable that it did a lot on parsing</li>
<li>But also not always what people were looking to understand in compilers class... [vs perhaps: what do the guts of an optimizing compiler look like, how do program transforms typically work, what can I expect a compiler to do / not do, etc]</li>
</ul>
</li>
</ul>
<h2>[01:20] Embracing Recursive Descent Parsers</h2>
<ul>
<li>A bit heretical, but part of what we're going to claim today is that parsers, in a practical sense, you can view as a stylized pattern of coding</li>
<li>With recursive descents parsers as a solution, you can easily create your own parsing scenarios &amp; solutions and reuse that understanding [e.g. even across languages, environments]</li>
</ul>
<h2>[1:40] Parsers Show Up All Over!</h2>
<ul>
<li>Parsers, when you get into them, show up <strong>all over the place</strong></li>
<li>People will say &quot;you can't just point at anything and call it a parser,&quot; but when you start loving parsers, you kind of do!</li>
<li>An example is CPU front-ends, the ones that decode the instructions</li>
<li>Really they are very compact, on-the-fly parser/generators for microcode</li>
<li>If you look at ARM64: it's 4-byte words that you parse one at a time, CPU parses it as any disassembler would do it, sometimes does it more than one word at a time, but basically a fancy parser</li>
<li>[And parsers that can vectorize with respect to input/output symbols are a whole other area of interest; e.g. in this example can you, in the average case, consume two 4B words and produce &gt;= 2 micro-ops in a given clock?]</li>
<li>x86 is a bit trickier as a front-end because the instruction size [input symbols] are variable length, variable-width encoding but still a kind of a parser</li>
<li>This is a type of parser that needs to have <strong>context</strong> to decode the instructions properly, e.g. starting at the right place [and in the right mode] to decode the right instructions</li>
<li>In fact, if you're mis-aligned, you could decode totally different instructions</li>
<li>Still effectively a very fancy parser!</li>
<li>In the realm of security, this is one of the fun things that <strong>shell code</strong> [attacker-controlled code buffer payload] will try to do to take advantage of this: place a bunch of constants into the code and jump to a weird offset, so the move-constant-to-reg instructions will be decoded differently via the immediates that are not at the intended &quot;start&quot; of the instruction</li>
</ul>
<h2>[2:50] Some Naive Background on the Parsing Process</h2>
<ul>
<li>As humans we often write text down using alphabets that we use to make composite words</li>
<li>We have &quot;parts of speech&quot; that put words in relation to one another to make sentences that have semantic meaning</li>
<li>Parsing for computer programs is analogous/similar in a lot of ways</li>
<li>We have scanned characters, like code points in unicode, which make up our alphabet</li>
<li>We use those to make up &quot;tokens&quot;, which are kind of like words</li>
<li>We put those tokens into a &quot;parse tree&quot;, that often relate values, which are like nouns, and verbs, which are like operators together</li>
<li>We can then define <strong>new composite things</strong> by putting all these primitive pieces together!</li>
<li>In this vein, if you've never watched <a href="https://www.youtube.com/watch?v=lw6TaiXzHAE">Guy Steele's &quot;Growing a Language&quot; talk</a> [OOPSLA'98], you probably want to push pause right now and go watch that, it's really good! [Apologies to listeners for the binary sex distinction made at the start, but it explained later in the talk how/why it is used as a rhetorical device.]</li>
<li><strong>Using Declarative Languages:</strong> often we use declarative languages to describe &quot;how to read in&quot; computer languages<ul>
<li>We use <strong>regular expressions</strong>, for example, to say how to scan tokens out of a character stream</li>
<li>We use little languages like <strong>BNF</strong> (Backus-Naur Form) that describe grammars of languages, the kind of &quot;recursive definition&quot;</li>
<li>e.g. an <em>arithmetic expression</em> can be made of &quot;weak arithmetic with additions/subtractions, which can have &quot;strong arithmetic&quot; expressions inside of it with multiplications/divisions; i.e.:<pre><code>ARITH_EXPR ::= WEAK_ARITH_EXPR
WEAK_ARITH_EXPR ::= STRONG_ARITH_EXPR [&quot;+&quot; STRONG_ARITH_EXPR]
STRONG_ARITH_EXPR ::= TERM_EXPR [&quot;*&quot; TERM_EXPR]
TERM_EXPR ::= Number
</code></pre>
</li>
<li>BNF restructured as these recursive rules for how to turn tokens into a tree, and that's the parse tree that we get out of the parsing process</li>
</ul>
</li>
</ul>
<h2>[4:25] Unicode-qua Parser</h2>
<ul>
<li>Example of &quot;pointing at a thing and calling it a parser&quot;</li>
<li>Unicode itself, need a form of parser for</li>
<li>Self-restarting parser: not that context-ful</li>
<li>Way [variable-length] unicode is encoded every UTF start, in UTF-8 for example, tells you where the start of the code point is</li>
<li>So if you miss one code point, the next one you won't be able to miss, because of the way is encoded</li>
<li>Very simple parser, but still something you would &quot;parse out&quot; of a byte stream</li>
<li>Parsers are everywhere!</li>
</ul>
<h2>[5:05] Questioning Conventional Wisdom? Trade-offs in Parser-Generation</h2>
<ul>
<li>Conventional wisdom out there is to ever write a parser by hand, but to always use a parser-generator</li>
<li>JF &amp; Chris generally think the conventional wisdom here is wrong</li>
<li>We would [for mission-mode projects] prefer to write a parser by hand: start with a recursive descent parser, and if that form causes issues, use more of a state-machine style form that tracks context/state when necessary</li>
<li>[Or sometimes over-recursion errors that come from an deep recursive structure can be transformed to be more iterative formulation, like <a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">precedence climbing</a>]</li>
<li>Recursive form is easy to write, and translating to more of a &quot;state machine&quot; form is not that bad</li>
<li>JF started his first parsers a long time ago with the conventional wisdom: tried a bunch of things</li>
<li>Tried ANTLR, tried lex/yacc &amp; flex/bison</li>
<li>Ended up with Boost Spirit -- in retrospect felt it was a bad idea: hard to write, hard to debug, not really flexible, gave terrible error messages, <em>but as a trade-off</em> gave terrible compile times too!</li>
<li>Silver lining of working in Boost Spirit all that time ago is JF gets to make fun of <a href="https://twitter.com/blelbach">Bryce Lelbach</a> -- friend of the show &amp; <a href="https://adspthepodcast.com/">ADSP podcast</a> host, worked on Spirit and JF always makes of him for that, silver lining in learning to disregard the conventional wisdom</li>
<li>Boost Spirit is kind of an EBNF Domain Specific Language (DSL) written in C++ Template Metaprogramming (TMP)<ul>
<li>If you look at EBNF it has special operators; some of these exist in C++'s overloadable operator set</li>
<li>Somebody went and made a clever C++ optimizer in template metaprogramming for a DSL language using templates and operator overloading, to made somewhat of an EBNF parser; very cute but kind of a silly idea honestly, would rather write all of that stuff by hand</li>
</ul>
</li>
<li>Think we, in industry, had a rude awakening [with Yacc] to see <code>.y</code> files trying to interleave various things into the parsing process; unclear lifetimes in the <code>.y</code> files, memory errors that would result -- part of what made JF love recursive descent parsing by contrast was that kind of stuff<ul>
<li>When I make fun of Boost Spirit I wouldn't say .y files are better than what you end up with there; really think recursive descent parsers are the right way to go: more malleable, nicer to write, easier to debug, &amp; etc</li>
</ul>
</li>
<li>For folks who haven't used Yacc before, <code>.y</code> files are stylized C templates that the Yacc parser can call into when events occur in the formation of the parse tree<ul>
<li>You create this &quot;hybridized, C-looking file&quot;, but where things are happening that are driven by the Yacc parser [as the main loop]</li>
<li>JF is personally a big fan of code generation: custom DSL that you (yourself) parse -- and generate C/C++ code to do things -- that your codebase uses; just seems like Yacc files are not the best compositional way do code generation</li>
<li>Increasing people are trying to create and use simple versions that operate more like that; in Yacc the inner loop driven by the theoretical LALR grammar composition -- i.e. there's something you don't understand that you'll get your shift reduce conflicts from in your inner loop, but that triggers events in this other file</li>
<li>Things like PEG grammars that people are trying to use more of now can end up spitting out a C file that <em>is</em> a recursive descent parser, but we'll talk about some of the trade-offs there as well</li>
<li>Even though things like PEG grammars are are a more modern technique that are spitting out recursive descent parser <em>implementations</em>, here we're mostly going to talk about the hand-rolled recursive descent parsers</li>
<li>Trade-off for hand-rolled ones is that they work well and are understandable when you structure them as code yourself, and really it just comes down to a stylized way of structuring your code to make a useful and easily-recognized data structure, which is the parse tree that comes out, or a nice error message that can use the context from where the error message occurred</li>
<li>Very good article that gives a counterpoint to our view that this is our preferred way to do it: <a href="https://tratt.net/laurie/blog/2023/why_we_need_to_know_lr_and_recursive_descent_parsing_techniques.html">Why We Need to Know LR and Recursive Descent Parsing Techniques</a><ul>
<li>[A key observation from this article is that we should all internalize: recursive descent parsers being &quot;just stylized code&quot; is both a blessing and a curse: you can write an ambiguity in your grammar like &quot;if it's Tuesday parse it this way&quot; and not skip a beat. Understanding how to make languages regular in form, even when they are implemented as hand-rolled recursive descent, is key. In a hand-rolled recursive descent parser, striving to write LL(1), for example, where you can disambiguate what direction the grammar is going with a single token of a lookahead, is a good thing.]</li>
</ul>
</li>
<li>Parsing historically was one of these great crossovers between fundamental CS and practical applications</li>
<li>You learn about it in a Theory of Computation class:</li>
<li>A regular expression has a certain level of power</li>
<li>Push-down automata are the next level of power that enable you to do things like match parentheses; e.g. when you have open a close parentheses<ul>
<li>You can't write an HTML parser, for example, using just regular expressions!</li>
</ul>
</li>
<li>So parsers are strictly more powerful than what you can do with regular expressions!<ul>
<li>People, as a result of the important theoretical basis, can feel that the underlying theory is important, which makes sense -- to the extent you can find yourself learning about Chompsky's theories and Cantor diagnalization proofs and things like this -- which are all important and great, knowing CS fundamentals is great!</li>
<li>Similarly, from a practitioner perspective, there's an aspect which says: if you just write code in a particular stylized way, you can accomplish your particular task, you can get done the job you want to get done; and, if you find the theory daunting, you may be able to skip over some of those fundamentals, and just learn to write this stylized form of code</li>
</ul>
</li>
<li>JF worked with someone 10 years ago or so who did their PhD on parsing -- perhaps today we think parsing is a well known field -- doing a PhD on that he significantly advanced the state of the art in CS in the 70s -- really tells you that computer science itself is a fairly novel field, lots of things were figured out fairly recently<ul>
<li>Interesting that we're in this field where things are so novel that it's possible to know folks who invented key things</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>[11:40] Recap basic flow of parsing</h2>
<ul>
<li><p>&quot;Tokenize&quot; the characters: linear stream of characters transforms into linear stream of tokens</p>
</li>
<li><p>Make a tree out of those tokens</p>
</li>
<li><p>Scanning and tokenization are synonyms</p>
</li>
<li><p>But even that fact is interesting: brings up questions like:</p>
<ul>
<li>&quot;is tokenization context-sensitive?&quot; and</li>
<li>&quot;how parallelizable is it with respect to the character stream?&quot;</li>
</ul>
</li>
<li><p>Sometimes want to split parsing and scanning [e.g. for nice separation of concerns], sometimes you want to join them</p>
</li>
<li><p>Scanning tends to have <em>very little</em> ‚Äåcontext -- usually only understands basic delimiters in the text itself</p>
</li>
<li><p>Whereas parsing tends to understand the context and the structure of the grammar that you're dealing with</p>
</li>
<li><p>The parser itself has a state, to understand where you are -- i.e. in a state machine, to decode the grammar that you're parsing</p>
</li>
<li><p>The parser generates an output: depends on what you're doing, could be an abstract syntax tree you generate from your parser</p>
</li>
<li><p>i.e. could generate code directly if you're a small/efficient [i.e. &quot;one pass&quot;] compiler</p>
</li>
<li><p>In a recursive descent parser, that state is partly encoded in the control flow itself: the function calls, what's on the stack, and so on, encodes some of the state</p>
</li>
<li><p>When we were discussing converting a recursive descent parser into more of a state machine, what you end up doing is looking at that state you had via recursion, and having your own stack  to encode that state as a side data structure</p>
</li>
<li><p>And this is a generally interesting thing in the way that we write sequential programs: the program counter is effectively a state that marches forward and takes jumps and things like this</p>
<ul>
<li>Recursive functions is one particular way to structure your state with data on the stack and the marching forward of the program counter in various ways</li>
</ul>
</li>
<li><p>[13:30] Like we were talking about, the tokens get formed from the character stream</p>
</li>
<li><p>Lookahead ahead at what token you see is part of what determine the grammar production (grammar rule) to apply</p>
</li>
<li><p>If I'm looking at the character stream and I'm holding something in my hand, and looking ahead I see the plus sign, I</p>
</li>
<li><p>Lookahead ahead at what token you see is part of what ultimately can determine the grammar rule to apply: if I'm looking ahead and I see a plus sign, I know this is probably a binary plus operator (in many common languages) that wants to take the thing I just saw on the left hand side and add it to a thing (I still have to determine) on the right hand side</p>
</li>
<li><p>And so what happens with these rules, is they nest: I'll take the plus operator and say &quot;ok I must be currently doing a weak arithmetic expression&quot; -- because times binds more tightly than plus, plus is &quot;weaker&quot;</p>
</li>
<li><p>So then I would look at the right hand side and ask &quot;can I parse what I see after the <code>+</code> as a <em>strong</em> arithmetic operation? Like a <code>*</code> maybe? One that <em>binds more tightly</em> than the plus I'm currently looking at as an operator?&quot;</p>
<ul>
<li>This binding or precedence level determines whether you nest the next expression at the same level or an increased level, like a tighter binding; i.e. the <code>*</code> would be more tightly binding than the <code>+</code> operator</li>
<li>So you set up your grammar rules so that things that <em>nest more tightly</em> become more interior nodes inside the tree</li>
<li>You do this using self-contained rules; e.g. <code>WEAK_ARITH_EXPR</code> above that has <code>STRONG_ARITH_EXPR</code> on the left hand side and right hand side</li>
<li>You stylize your grammar recursive functions / BNF grammar to make this association clear</li>
</ul>
</li>
</ul>
<h2>[15:10] JavaScript Fanciness: Outlining Functions</h2>
<ul>
<li>In JavaScript land, beyond these basic flows of how grammars work, there are some cool and fancy things</li>
<li>Imagine there are hundreds of functions in the file, peek at where the beginning/end of the functions are so I can lazily load in the tree that describes the syntax (i.e. lazily parse it)</li>
<li>Imagine I never end up calling a particular function, do I really want to spend cycles parsing and analyzing it if I never call it?</li>
<li>But can also be interesting challenges: tokenization, for example! If you're in a regular expression you might switch your scanner from regular expression mode to normal JavaScript code mode</li>
<li>Or if you find yourself in the middle of a multi-line comment there could be arbitrary stuff in there that doesn't do anything at all!</li>
<li>Challenges in doing advanced/fast/concurrent scanning or tokenization</li>
<li>When you try to parallelize things you need to have enough work in each parallel worker to do something useful: classic parallelism/concurrency tradeoff -- do you go off and optimize  all the functions at this point?<ul>
<li>You have a quick parallelel parser that figures out where the start/ends are -- do you fork off work to N threads to quickly optimize all of them, or maybe do some extra amount of parsing, or do you just keep that information around and do that lazily with an interpreter when you end up executing it? And then Just-in-Time compile it? <em>And then</em> do you Just-In-Time with a foreground thread or a background threads, part of the trade-off</li>
<li>Parallelization is a good way to use multiple cores, but for lower latency page load maybe you want to block and compile right there/then on the foreground thread and do the work as it comes in</li>
<li>Always an interesting trade-off to see if you tie in parsing with optimization or other kinds of context generation</li>
</ul>
</li>
</ul>
<h2>[17:15] Backtracking</h2>
<ul>
<li>To pull back a bit from the advanced techniques we're talking about and go back to fundamentals of parsing</li>
<li>One of very important aspects of parsing is this concept of backtracking</li>
<li>Just like you speculatively might parallelize for parsing javascript on a page or something like this</li>
<li>In the parsing process itself when there's something ambiguous to do: you see a <code>&lt;</code> operator -- you're not sure if that's starting a template instantiation in C++ or doing a less-than operation -- when you see that <code>&lt;</code> in C++ it could mean one of two things, so you have this ambiguous choice</li>
<li>Backtracking basically means capturing your current point in the process of parsing, and being able to revisit that choice and make a different choice</li>
<li>So you might speculate that this <code>&lt;</code> operator is going to be an actual less-than operator, and you might go try to parse as-if that's the case, and if you find that was an error, you may go back, restore your original context, and go down the opposite path [of a template instantiation]</li>
<li>Some languages can be more regular and require less-backtracking or no-backtracking, and there's a whole description of what languages can have this property in the theory -- it's an important concept that gets introduced when you grammar isn't fully determined by look-ahead tokens, so this is a property than many real-world languages do have that we use in computers</li>
<li>[18:55] Rust relatedly has this &quot;turbo fish&quot; operator that helps resolve the ambiguity mentioned in C++ -- instead of seeing the <code>&lt;</code> symbol and thinking &quot;maybe that's a template instantiation&quot; there's an explicit operator which is <code>::&lt;</code> that says to the parser &quot;the thing on the left hand side of this operator is a type name being instantiated, I'm telling you that it is!&quot; Interesting solution for making things less ambiguous as the cost of thing having more punctuation in the lines</li>
<li>Haskell relatedly has the ability for users to create whole new infix operators, so you can extend the grammar e.g. with the Kirby operator <code>&lt;(o.o)&gt;</code> (or maybe not quite that far) -- but almost arbitrary punctuation can become new infix operators</li>
<li>Things like <a href="https://en.wikipedia.org/wiki/Camlp4">CamlP4</a> [ed: my bad I misremembered and said Caml4P] were in the history/insiration of the Rust macro creation, where things are extensible in user space so the syntax can be extended so you can build new parse trees and constructs</li>
<li>[20:00] For backtracking in general but also in parsing you have these decision points where you make have to throw away work done in some subtree and then go on to make a different choice until you figure out what the actual subtree was</li>
<li>Similar to all transactional things: make continuation point you may choose to revisit, until you decide that, &quot;ok I actually finished and I never need to revisit&quot;, and then you actually commit that and pass your &quot;Point of No Return&quot;</li>
<li>[20:28] Backtracking also reminds us: designing a parser is something you want to do ideally while you design the grammar you want to parse itself</li>
<li>A lot of grammars are designed in a way that ought to be easy to parse, some of the thinking is: it's not only easy for a programmer to write a parser, it's also easy for a human to understand what's written</li>
<li>In C++ we were talking about the <code>&lt;</code> operator; those familiar with C++ in a template context, you end up having to specify typename and template</li>
<li><code>typename</code> and <code>template</code> keywords have a few different meanings -- in a template context it disambiguates certain things; when C++ was designed its grammar was realized to be quite complex and those keywords are there to help disambiguate some of the things, not only for parsers, but for humans as well</li>
<li>When they were creating Go this was a big focus -- they wanted to have a grammar that was not just for humans, but <em>also</em> easy to parse, and so they ended up having some things like types following identifiers</li>
</ul>
<h2>[21:30] How doth a tree grow?</h2>
<ul>
<li>[21:30] Basic thing we're burying in talking about recursive descent parsers primarily is whether parse trees should grow from the leaves to the root, or visa versa</li>
<li>If you look at a graph: from the bottom of the graph or the root at the top?</li>
<li>Joke here: <em>real</em> trees probably have a strong preference in which direction things grow! But in CS trees you get to choose how trees grow</li>
<li>In LL and recursive descent, that's usually top-down, start at the root; LALR / bottom up parsing starts at the leaves / terminals of the grammar</li>
<li>Trade-offs in choosing each of these based on what it is you're parsing: what is the language/grammar you're looking at</li>
<li>Sometimes recursing &quot;from the left&quot; / &quot;from the right&quot; may have more backtracking and therefore be less efficient</li>
<li>Again, designing your grammar with the parser makes trade-offs in how things are efficient and how you implement the parsing</li>
<li>Ultimately comes down to how ambiguities are resolved and when they're detected during the parsing process</li>
<li>Shift-reduce conflicts are notorious here and come from ambiguities in the bottom-up merging process</li>
<li>What's neat about recursive descent parsers is you're really just writing code, resolving conflicts with the code that you write -- one of the things that can be nice, if you're not careful you don't even notice you're doing it -- what's bad is the same thing that's good, you're just writing code, sometimes it's nice, sometimes it's a great way to make a mess</li>
<li>Very powerful tool, with great power comes great responsibility</li>
<li>Can easily say &quot;the grammar parses this way when it's a Wednesday after 4pm&quot;, but that would be a terrible parser to write, even thought it's possible in a recursive descent parser</li>
<li>What the structure of these declarative things is forcing you to do is say: &quot;it follows this regular structure, and it has ways of resolving ambiguities that I placed in my specification up front&quot;</li>
</ul>
<h2>[23:53] To hand-roll or to generate: <em>that</em> is the question!</h2>
<ul>
<li>[23:53] Back to what we were talking about at the beginning on the trade-off between parser-generators and hand-rolled recursive descent parsers: no way to avoid the language of trade-offs</li>
<li>Some things might consider are: performance; when you parser-generator gives you something that gives a certain performance in parsing, what are your tools/techniques for getting more performance out of the system, e.g. parsing more megabytes of text per second into your data structure</li>
<li>With code in your hand in a recursive descent parser, we can use a lot of our conventional techniques for optimization, whereas with a parser-generator restructuring the grammar or perhaps providing hints to the parser-generator are ways you might do it in a generated scenario</li>
<li>When you're writing code you have more control over memory usage and how things gets structured; e.g. if there are peak memory limits you want to stay within, or if you have some kind of divide-and-conquer you may be able to do</li>
<li>When you have the code in your hand you have all the control and the power, but at the cost of some additional code writing and extra work for you</li>
<li>Error mesages are a pretty important point we have to talk about more:</li>
<li>Things like <strong>inline diagnostics</strong>: say you get part of the way through parsing your program, but then you find that there's some problem, diagnostics on the partially-completed parse process are very important to be able to feed back to the user<ul>
<li>&quot;I got to this point but then I saw that <code>$THIS_THING</code>, in particular, went wrong&quot;</li>
</ul>
</li>
<li>Tracking state for diagnostics like this in a &quot;sidecar&quot; for diagnostic purposes as you parse is a really powerful tool in recursive descent parsers</li>
<li>If you look at Clang -- the C++ front-end -- it always tracks potential errors / diagnostics in a side-state while it's parsing -- it's always keeping track of a bunch of things<ul>
<li>If it encounters a problem it will print it out of the diagnostic, if it is is enabled, otherwise it will just kind of &quot;keep going&quot;</li>
<li>This also allows it to print out diagnostic context more easily, because it keeps track of context while it's doing the parsing</li>
<li>Diagnostic information itself can lead to better error <em>correction</em> as well -- to keep making progress, you may want to keep parsing instead of just giving up on the first encountered error</li>
<li>Some languages want to give more useful errors, not just the first one in the compiler invocation</li>
<li>Particularly if the compile time is slow! Want to have a handful of errors you can address, not just the first one, before recompilation</li>
<li>Kind of similar to &quot;lax mode&quot; in HTML &quot;quirks&quot; parsing</li>
<li>If you know the history of HTML, there's been these back-and-forths with XHTML and HTML5 and the previous versions</li>
<li>There were people who were very religious about &quot;HTML has to parse exactly correct and any small error you should not render a webpage&quot; vs &quot;HTML should be parseable... kinda... whatever!&quot; [c.f. <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel's Law</a>]</li>
<li>If you look at HTML parsers nowadays in browsers they do very interesting things to be able to form slightly misformed HTML that &quot;happens to work&quot;</li>
<li>Ability to handle error messages and error cases very well using partially constructed information does end up hurting the ability to modularize [the parsing process] a bit -- you end up wanting to reach in to the &quot;surrounding&quot; &quot;what didn't finish yet?&quot; &quot;how much of it did get done?&quot;<ul>
<li>Can often prevent you from creating little very easily pluggable modules, we'll talk a little bit more about that</li>
</ul>
</li>
</ul>
</li>
<li>[27:30] Have seen arguments against recursive descent parsers in the sense of: &quot;what if the grammar is changing a lot?&quot; In the case could make you do significant changes to the recursive descent parser code that you wrote [vs more simply changing BNF]<ul>
<li>In personal experience, things evolve structure over time in a way that can compose function-wise; these functions are defined in productions / helpers inside of your grammar</li>
<li>Usually productions don't disappear entirely or get 100% re-worked in the language, vs getting tweaked and/or refactored</li>
<li>So declarative specifications like BNF are good but there's also some trade-offs around driving everything off of them</li>
<li>If you wanted to have multiple versions of your language, for example, say you wanted to be able to ingest version 1, make some internal AST changes, and then format out version 2 via some formatting methodology like clang-format or something similar</li>
<li>Nice to be able to have simultaneous parsers/formatters there with common sub-routines between them even though they are differing sub-versions of the language which may have differing BNF</li>
<li>On the point of modularity: there are also parser &quot;combinators&quot; which are really cool -- functions that have the same API for doing things -- general idea of combinators are lego bricks you can plug together because they have a uniform interface</li>
<li>Challenge with those is, because they have a uniform interface, they can't pass side-band information between each other easily, because they all take a stream of tokens in, say, and produce some sub-fragment of the AST out</li>
<li>So handling that global context/state of error messages and things can be more difficult: how does that side-band information come in to play?</li>
<li>Although combinators can be difficult for getting the best error message experience in my experience, they're really nice when the UX is less important, because you can make them very quickly in the same sense as parser-generators</li>
<li>One cool case study: because formatting is the inverse function of parsing, you can make one combinator that both parses and formats out its input, and we did that for example for TPU assembly, for example</li>
<li>Can create a little environment of data that came from parsing the assembly, and use that <em>same</em> environment for formatting the assembly out with the same combinator</li>
<li>Nice that these functions can be easily inverted when you plug them together in this combinator sort of way</li>
</ul>
</li>
</ul>
<h2>[30:15] Engineer / Pig-Mud Equilibrium</h2>
<ul>
<li>We're both engineers and we like to get our hands dirty, way JF likes to describe it is as the saying goes, &quot;It's like wrestling in the mud with a pig, at some point you realize that the pig likes it&quot;</li>
<li>We like to get our hands dirty with code</li>
<li>Few times we got our hands dirty with parsers</li>
<li>We worked on an array database query language that had operators that associated right-to-left<ul>
<li>You make a right leaning tree instead of a left-leaning one, meaning the outer-most expression is on the right hand side of the screen, interesting code base!</li>
<li>First time seeing idea that operators would apply right-to-left, made for an interesting parser</li>
</ul>
</li>
<li>Features that were somewhat notorious we got exposed to in JavaScript that had funny grammatical properties, like its Automatic Semicolon Insertion (ASI)<ul>
<li><p>Normal BNF grammars don't have a notion of a &quot;negative lookahead&quot;; like &quot;there can not be this terminal here&quot;, but that's how ASI was described in the JavaScript spec</p>
</li>
<li><p>In Firefox SpiderMonkey [JS engine] we had a recursive descent parser, so it was very clear how that kind of &quot;production rule extension&quot; could be handled, but believe [OS X Safari] JavaScriptScore had a lex/yacc based parser -- not exactly sure how it handled things like this negative token lookahead, but would be interesting to go back and find out; how did it deal with this extension to the BNF grammar that was present in the JavaScript spec</p>
</li>
<li><p>ASI one of the strange quirks of JavaScript people ideally do not rely on, but makes it an interesting language to parse; interesting accident</p>
</li>
<li><p>&quot;If there would be an error, but putting a semicolon there would make it not-an-error, then you should put a semicolon there&quot; is perhaps the rule</p>
</li>
<li><p>[32:30] When JF worked on Chrome's Native Client security sandbox, the parsing had to be correct, or it was a potential security vulnerability</p>
</li>
<li><p>Idea of Native Client back when it started in 2009 -- <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/34913.pdf">really great paper describing it</a> -- let's try to run native code run on the web</p>
</li>
<li><p>At the time had written V8 and realized there's a wall you hit with JavaScript regardless of how much your compiler can optimize things for JavaScript and kind of want to run more powerful things on the web</p>
</li>
<li><p>Native Client isn't what ended up being standardized, Web Assembly was</p>
</li>
<li><p>But core idea of running native code on the web was really interesting, and there were different experiments: NaCl, PNaCL, and at Mozilla there was asm.js which ended up with us creating Web Assembly together</p>
</li>
<li><p>In all those contexts the parser is really really critical to get right, if you don't get it right there's a vulnerability</p>
</li>
<li><p>When JF worked on Native Client the input was x86-32 x86-64 and ARM, so there's really tricky things and parsing those ISAs correctly is important to security</p>
<ul>
<li>The CPU is just going to execute it, so if you haven't validated the executable correctly, something else is going to be executed which may be a vulnerability</li>
<li>One fun bug the team had to resolve early way before launch was dealing with <code>pushf</code> / <code>popf</code> instructions in x86</li>
<li>Those tend to just push the flags, overflow flag and such</li>
<li>But because of the way x86 is made, it has interesting flags nobody really uses; e.g. direction flag you can save and restore, which sets the direction of the <code>REP</code> prefix instructions</li>
<li><code>REP</code> is the &quot;repeat&quot; prefix which ends up being used in things like memcpy [which can be implemented via <code>REP MOVSB</code>] -- when you change the <code>REP</code> prefix you can change the direction flag to make that memcpy go backwards</li>
<li>Interesting but a great way to write vulnerabilities; if you're trying to bounds check things, you see a <code>REP</code> instruction, you &quot;know&quot; it's going to go in increasing addresses, but if you set the flags differently it goes backwards! This lets you go out of bounds and create an exploit chain</li>
<li>Interesting part of parsing we had to get right was in ARMV7, some interesting features, can change from one endianness to another (and sub- instruction set, e.g. Thumb) <em>during</em> execution -- if you see those instructions that change endianness or instruction set one thing you can do is just disallow them; if you try to handle them can be tricky to do very well, giant context change for a parser, not something wanted to allow so just disallowed it in the parser; other interesting pieces like Jazelle in ARM too</li>
<li>Other cool stuff that came out of the NaCl team: at some point the team wrote an auto-generated x86 parser; had a description of the x86 they wanted to handle, auto-generated the parser from that description</li>
<li>Code generated was so big was the biggest set of functions inside of Chrome, blew up Visual Studio really badly, had some behavior where it gave up and generated very terrible code, until they figured out how to tune the code generator to split up what it generated so Visual Studio wouldn't choke on it</li>
<li>Also one of the things to bring up as one of the potential pitfalls for Recursive Descent Parsing; you have these production rules -- your functions represent grammar production rules -- they're all co-recursive, they're all calling in to each other -- some of them will be hotter than others, some will be smaller handling code thats inlined into outer sites that try to implement parts of the grammar, so sometimes can get giant mega-frames, end up with tons and tons of stack data when you call a particular functions</li>
<li>Can end up with giant frames leaping over guard pages or terrible things that end up with the OS not paging in the next stack page appropriately -- something to watch out for, these giant stack frames / stack overflows that cause segmentation faults</li>
<li>JF worked on another cool parser, good chunk of parser for WebAssembly inside of WebKit, and testing and things, wrote the core of it and folks wrote the rest of the parsing, that is also security sensitive, WebAssembly kind of a stack machine little language, but all byte oriented when you parse it, and has to be secure: if you don't parse it properly you wind up having vulnerabilities, but also in those cases want to have good error messages, because it's a bunch of bytes you push in, so a developer being able to look at the error messages with WebAssembly is very important</li>
<li>Something JF liked doing to solve the parsing of WebAssembly in WebKit was using a recursive descent parser, but used the C++ <code>std::expected&lt;T, E&gt;</code> type to return a result or an error</li>
<li>What was nice in a recursive descent parser where you have an <code>expected</code> is it's basically impossible to ignore the errors when you do this -- if you set it in a mode where any access of the wrong thing is going to fail, and where you cannot disregard the return value of something, makes it <em>almost</em> correct by construction when you write the parser</li>
<li>Or not necessarily correct by construction, because you still need to treat the information correctly, but makes it much easier to do the right thing and harder to do the wrong thing</li>
<li>If you compose it well, it's hard to get things like integer overflows, or out of bounds accesses, or things like that, when you're doing the parsing, because you're building it out of basic parts that you put together</li>
<li>Ends up being interesting to write a security-sensitive parser with modern tools like that</li>
<li>Nice example story -- <code>std::expected</code> is easy to like, Chris hopes there's a <code>?</code> <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">operator for it like in Rust one day</a>, so if there's C++ committee people listening...</li>
<li>JF says there's not for now but there's the monadic operators for C++23 the same way they're added for <code>std::optional</code><ul>
<li>Not quite the same power as the <code>?</code> operator or something like it, but somewhat novel... JF not sure it'll make it to C++26</li>
<li>JF says what's nice is you can write the scope in the if declaration position as a neat syntactic thing in C++:</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">if (auto something = make_my_expected_thing()) {
  // happy case using &quot;something&quot;
} else {
  // sad case using &quot;something&quot;
}
</code></pre>
<pre><code>  * [Chris quietly thinks this is a sad consolation prize]</code></pre>
<p>* One other story: Chris works on a team that parses SystemVerilog using ANTLRv4 that may be the largest ANTLR grammar
* We've been talking a bit about the trade-offs we see there
* Performance optimization work sometimes means re-structuring the grammar so that the generator can do better with it
* Same interesting questions come up around memory usage and you get a lot of power from the grammar-generating that would be a lot of work to write in a recursive-descent parser form, especially as the grammar gets large
* But there's clearly a trade-off space there, been fun to re-live this understanding of the tradeoffs</p>
</li>
</ul>
</li>
<li>One last thing we wanted to touch back on: difference between parse trees and Abstract Syntax Trees (ASTs)<ul>
<li>We threw the terms around a bit here</li>
<li>Think it's not <em>formally</em> defined</li>
<li>But notion that a parse tree is literally the fully tree that comes straight out of the grammar's structure</li>
<li>Whereas AST will be &quot;more reduced form&quot; -- e.g. if I have a bunch of <code>+</code> operators strung together at the same precedence level, if I make an n-ary node that has all the operands to the strung together <code>+</code>s, that's not <em>strictly</em> what the grammar specified [it would have been deeply nested] but it's equivalent in representation, if simplied</li>
<li>So how people tend to talk about AST vs parse trees</li>
</ul>
</li>
<li>Good amount of knowledge talked about parsers today</li>
<li>Adjourn and meet soon for another deep dive into interesting geeky topic</li>
</ul>
    </main>
    <script>const setPlaybackSpeed = speed => { [].slice.call(document.querySelectorAll('audio,video')).map((e, idx) => { e.playbackRate = speed; }); }</script>
  </body>
</html>
