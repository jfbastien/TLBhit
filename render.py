#!/usr/bin/env python3
"""
TLB Hit build script.
Generates HTML episode pages and podcast RSS feed.

Usage:
    source .venv/bin/activate
    python render.py
"""

import os
import re
from pathlib import Path
from email.utils import parsedate_to_datetime
import xml.etree.ElementTree as ET

import yaml
import mistune

# === Namespaces ===
ITUNES_NS = "http://www.itunes.com/dtds/podcast-1.0.dtd"
CONTENT_NS = "http://purl.org/rss/1.0/modules/content/"
ATOM_NS = "http://www.w3.org/2005/Atom"
PODCAST_NS = "https://podcastindex.org/namespace/1.0"

# === Channel Configuration ===
CHANNEL = {
    "title": "TLB Hit ðŸ’¥",
    "link": "https://tlbh.it/",
    "description": "A podcast about systems & compilers by @jfbastien and @cdleary. The only podcast you listen to at 0.5Ã—.",
    "language": "en",
    "author": "JF Bastien & Chris Leary",
    "copyright": "Chris Leary & JF Bastien",
    "image": "https://tlbh.it/logo/tlbhit-logo.png",
    "categories": ["Technology"],
    "explicit": "false",  # Must be "true" or "false" per Apple docs
    "feed_url": "https://tlbh.it/feed.xml",
    "audio_base_url": "https://tlbh.it/episodes",
}

EPISODE_NOTES_DIR = Path("episode_notes")
EPISODES_DIR = Path("episodes")


def parse_frontmatter(content):
    """Extract YAML frontmatter and markdown body from content."""
    if content.startswith("---"):
        parts = content.split("---", 2)
        if len(parts) >= 3:
            fm = yaml.safe_load(parts[1])
            body = parts[2].lstrip("\r\n")  # Strip leading newlines for stable title extraction
            return fm, body
    return {}, content


def audio_player_html(ep):
    """Generate audio player HTML from episode frontmatter."""
    audio_url = f"{CHANNEL['audio_base_url']}/{ep['audio']}"
    return f'''<audio id="audioplayer" src="{audio_url}" controls="controls" class="podcast-audio" preload="auto"></audio><div class="playback-rate-controls"><ul><li><a href="#" onclick="setPlaybackSpeed(0.5)">0.5â¨‰</a></li><li><a href="#" onclick="setPlaybackSpeed(1)">1â¨‰</a></li><li><a href="#" onclick="setPlaybackSpeed(1.25)">1.25â¨‰</a></li><li><a href="#" onclick="setPlaybackSpeed(1.5)">1.5â¨‰</a></li><li><a href="#" onclick="setPlaybackSpeed(1.75)">1.75â¨‰</a></li><li><a href="#" onclick="setPlaybackSpeed(2)">2â¨‰</a></li></ul></div>
'''


def load_all_episodes():
    """Load all episode metadata from markdown frontmatter."""
    episodes = []

    for md_file in EPISODE_NOTES_DIR.glob("*.md"):
        if md_file.name.endswith("~"):  # Skip backup files
            continue

        content = md_file.read_text(encoding="utf-8")
        fm, body = parse_frontmatter(content)

        # Fail build if audio HTML found in markdown (should be auto-generated)
        if '<audio id="audioplayer"' in body or 'playback-rate-controls' in body:
            raise ValueError(f"ERROR: {md_file.name} contains embedded audio HTML. "
                           "Remove it - audio player is auto-generated from frontmatter.")

        if not fm.get("guid"):
            print(f"WARNING: {md_file.name} has no GUID in frontmatter, skipping RSS")
            continue

        fm["md_file"] = md_file.name
        fm["md_body"] = body
        fm["slug"] = md_file.stem
        episodes.append(fm)

    # Sort by episode number (stable, correct ordering)
    episodes.sort(key=lambda e: e.get("episode", 0))
    return episodes


def generate_html(episodes):
    """Generate HTML episode pages."""
    with open("episode_header.tmpl") as f:
        header_template = f.read()
    with open("episode_footer.tmpl") as f:
        footer_template = f.read()

    for ep in episodes:
        md_file = ep["md_file"]
        slug = ep["slug"]
        body = ep["md_body"]

        # Extract title from first line (must start with "# ")
        title_line = ""
        body_lines = body.split("\n")
        if body_lines and body_lines[0].strip().startswith("# "):
            title_line = body_lines[0]
            body = "\n".join(body_lines[1:])

        # Render markdown
        title_html = mistune.html(title_line) if title_line else ""
        body_html = mistune.html(body)

        # Prepare header with episode title
        display_title = ep.get("title", slug)
        this_header = header_template.replace("{episode_title}", f"Episode {ep.get('episode', '?')}: {display_title}")

        # Write HTML file
        html_path = Path(f"{slug}.html")
        with open(html_path, "w", encoding="utf-8") as f:
            f.write("<!-- DO NOT EDIT -- episode notes autogenerated by TLBHit's render.py -->\n")
            f.write(this_header)
            f.write(title_html)
            # Always generate audio player from frontmatter
            if ep.get("audio"):
                f.write(audio_player_html(ep))
            f.write(body_html)
            f.write(footer_template)

        print(f"Generated {html_path}")


def generate_rss(episodes):
    """Generate podcast RSS feed."""

    # Register namespaces ONLY (do NOT set xmlns attrs manually)
    # This prevents duplicate namespace declarations in output
    ET.register_namespace("itunes", ITUNES_NS)
    ET.register_namespace("content", CONTENT_NS)
    ET.register_namespace("atom", ATOM_NS)
    ET.register_namespace("podcast", PODCAST_NS)

    # Root element - just version, namespaces added automatically
    rss = ET.Element("rss", {"version": "2.0"})
    channel = ET.SubElement(rss, "channel")

    # === Channel metadata ===
    ET.SubElement(channel, "title").text = CHANNEL["title"]
    ET.SubElement(channel, "link").text = CHANNEL["link"]
    ET.SubElement(channel, "description").text = CHANNEL["description"]
    ET.SubElement(channel, "language").text = CHANNEL["language"]
    ET.SubElement(channel, "copyright").text = CHANNEL["copyright"]

    # Atom self-link (ensures xmlns:atom appears)
    ET.SubElement(channel, f"{{{ATOM_NS}}}link", {
        "href": CHANNEL["feed_url"],
        "rel": "self",
        "type": "application/rss+xml",
    })

    # iTunes channel tags
    ET.SubElement(channel, f"{{{ITUNES_NS}}}author").text = CHANNEL["author"]
    ET.SubElement(channel, f"{{{ITUNES_NS}}}explicit").text = CHANNEL["explicit"]
    ET.SubElement(channel, f"{{{ITUNES_NS}}}type").text = "episodic"
    ET.SubElement(channel, f"{{{ITUNES_NS}}}image", {"href": CHANNEL["image"]})

    # Categories
    for cat in CHANNEL["categories"]:
        ET.SubElement(channel, f"{{{ITUNES_NS}}}category", {"text": cat})

    # NEW FEED URL TAG - for migration (safe to leave forever)
    ET.SubElement(channel, f"{{{ITUNES_NS}}}new-feed-url").text = CHANNEL["feed_url"]

    # Podcast 2.0 namespace tags
    locked = ET.SubElement(channel, f"{{{PODCAST_NS}}}locked", {"owner": "tlbhit@jfbastien.com"})
    locked.text = "no"

    # podcast:guid - permanent unique identifier for the podcast (not per-episode)
    # Generated as UUID v5 from feed URL for stability
    import uuid
    podcast_guid = uuid.uuid5(uuid.NAMESPACE_URL, CHANNEL["feed_url"])
    ET.SubElement(channel, f"{{{PODCAST_NS}}}guid").text = str(podcast_guid)

    # Channel dates (from episodes, sorted by episode number)
    if episodes:
        ET.SubElement(channel, "pubDate").text = episodes[0]["pubDate"]
        ET.SubElement(channel, "lastBuildDate").text = episodes[-1]["pubDate"]

    # === Episode items (newest first for display) ===
    for ep in reversed(episodes):
        item = ET.SubElement(channel, "item")

        # Title
        full_title = f"Episode {ep['episode']}: {ep['title']}"
        ET.SubElement(item, "title").text = full_title

        # Link to episode page
        ET.SubElement(item, "link").text = f"https://tlbh.it/{ep['slug']}.html"

        # GUID - CRITICAL: exact value from Libsyn, isPermaLink="false"
        guid_elem = ET.SubElement(item, "guid", {"isPermaLink": "false"})
        guid_elem.text = ep["guid"]

        # Dates
        ET.SubElement(item, "pubDate").text = ep["pubDate"]

        # Description (both RSS and content:encoded)
        desc = ep.get("description", "")
        ET.SubElement(item, "description").text = desc
        ET.SubElement(item, f"{{{CONTENT_NS}}}encoded").text = desc

        # Enclosure - CRITICAL: length must be exact bytes
        audio_filename = ep["audio"]
        audio_path = EPISODES_DIR / audio_filename
        if audio_path.exists():
            length_bytes = audio_path.stat().st_size
        else:
            print(f"WARNING: {audio_path} not found, using 0 for length")
            length_bytes = 0

        ET.SubElement(item, "enclosure", {
            "url": f"{CHANNEL['audio_base_url']}/{audio_filename}",
            "length": str(length_bytes),
            "type": "audio/mpeg",
        })

        # iTunes item tags
        ET.SubElement(item, f"{{{ITUNES_NS}}}duration").text = ep.get("duration", "00:00:00")

        # Episode number - CRITICAL: must be positive integer (1-indexed)
        itunes_ep_num = ep.get("episode", 0) + 1
        ET.SubElement(item, f"{{{ITUNES_NS}}}episode").text = str(itunes_ep_num)

        # Explicit - CRITICAL: must be "true" or "false" (not yes/no)
        explicit_val = ep.get("explicit", False)
        explicit_str = "true" if explicit_val else "false"
        ET.SubElement(item, f"{{{ITUNES_NS}}}explicit").text = explicit_str

        ET.SubElement(item, f"{{{ITUNES_NS}}}episodeType").text = "full"

    # Write with XML declaration
    tree = ET.ElementTree(rss)
    ET.indent(tree, space="  ")
    tree.write("feed.xml", encoding="UTF-8", xml_declaration=True)
    print("Generated feed.xml")


def main():
    print("Loading episodes...")
    episodes = load_all_episodes()
    print(f"Found {len(episodes)} episodes")

    print("\nGenerating HTML...")
    generate_html(episodes)

    print("\nGenerating RSS feed...")
    generate_rss(episodes)

    print("\nDone!")


if __name__ == "__main__":
    main()
