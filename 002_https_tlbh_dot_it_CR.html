<!-- DO NOT EDIT -- episode notes autogenerated by TLBHit's render.py -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <title>TLB hit üí• Episode 2: `https://tlbh.it^M`</title>
    <style>
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 100; src: local('Alegreya Sans Thin'), local('AlegreyaSans-Thin'), url('./fonts/AlegreyaSans-Thin.woff2') format('woff2'), url('./fonts/AlegreyaSans-Thin.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 300; src: local('Alegreya Sans Light'), local('AlegreyaSans-Light'), url('./fonts/AlegreyaSans-Light.woff2') format('woff2'), url('./fonts/AlegreyaSans-Light.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: italic; font-weight: 300; src: local('Alegreya Sans Light Italic'), local('AlegreyaSans-LightItalic'), url('./fonts/AlegreyaSans-LightItalic.woff2') format('woff2'), url('./fonts/AlegreyaSans-LightItalic.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans'; font-style: normal; font-weight: 400; src: local('Alegreya Sans Regular'), local('AlegreyaSans-Regular'), url('./fonts/AlegreyaSans-Regular.woff2') format('woff2'), url('./fonts/AlegreyaSans-Regular.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 300; src: local('Alegreya Sans SC Light'), local('AlegreyaSansSC-Light'), url('../fonts/AlegreyaSansSC-Light.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-Light.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 400; src: local('Alegreya Sans SC Regular'), local('AlegreyaSansSC-Regular'), url('../fonts/AlegreyaSansSC-Regular.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-Regular.woff') format('woff'); font-display: fallback; }
      @font-face { font-family: 'Alegreya Sans SC'; font-style: normal; font-weight: 800; src: local('Alegreya Sans SC ExtraBold'), local('AlegreyaSansSC-ExtraBold'), url('../fonts/AlegreyaSansSC-ExtraBold.woff2') format('woff2'), url('../fonts/AlegreyaSansSC-ExtraBold.woff') format('woff'); font-display: fallback; }

      body { font-family: "Alegreya Sans", Arial, Helvetica, sans-serif; font-weight: 300; }
      header { max-width: 50em; margin: 0 auto; padding: 0 1em; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; }
      header h1 { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 800; margin-bottom: 0; display: flex; flex-direction: column; }
      header h1 a { text-decoration: none; }
      header div { display: flex; flex-direction: column; margin: 1em 0 0 0; }
      header p { margin: 0; text-align: right; }
      header p:first-child { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 300; }
      h2 { font-family: "Alegreya Sans SC", Arial, Helvetica, sans-serif; font-weight: 400; }
      main { max-width: 50em; margin: 0 auto; padding: 0 1em; }
      article { padding: 1em 0; }
      ul { list-style-type: circle; }
      .grid .entry { padding: 1em 0 1em 0; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; }
      .grid h3 { margin: 0; font-weight: 400; }
      .grid .entry .where { display: flex; flex-direction: column; flex-basis: 8em; }
      .grid p, .grid ul { margin: 0; }
      .grid ul { padding: 0 0 0 1em; }
      .grid .where p { font-weight: 100; }
      .grid .entry .what { display: flex; flex-direction: column; flex-basis: 30em; }
      .grid .short { padding: 0.2em 0 0.2em 0; }
      .grid .short .where { display: flex; flex-direction: row; }
      .grid .short .where h3, .grid .short .where p { width: 5em; }

      @media (prefers-color-scheme: dark) {
          body { background-color: #121212; color: white; }
          a:link { color: #bb86fc; }
          a:visited { color: #3700b3; }
      }

      .podcast-audio { width: 100%; }
      .playback-rate-controls ul { margin: 0; padding: 0; list-style: none; text-align: center; }
      .playback-rate-controls li { display: inline; }
      .playback-rate-controls li:not(:last-of-type)::after { content: " | "; }
      .playback-rate-controls ul li a { text-shadow: none; }
    </style>
  </head>
  <body>
    <header>
      <h1><a href='index.html'>TLB hit üí•</a></h1>
      <div>
      <p>A podcast about systems &amp; compilers</p>
      <p>üê¶ <a href="https://twitter.com/TLBhit">@TLBhit</a></p>
      <p>üéô <a href="https://tlbhit.libsyn.com/rss">RSS</a></p>
      <p>üçé <a href="https://podcasts.apple.com/us/podcast/tlb-hit/id1538369465">Apple podcast</a></p>
      </div>
    </header>
    <main>
<h1>Episode 2: <code>https://tlbh.it^M</code></h1>
<audio id="audioplayer" src="https://traffic.libsyn.com/secure/tlbhit/tlbhit2.mp3" controls="controls" class="podcast-audio" preload="auto"></audio><div class="playback-rate-controls"><ul><li><a href="#" onclick="setPlaybackSpeed(0.5)">0.5‚®â</a></li><li><a href="#" onclick="setPlaybackSpeed(1)">1‚®â</a></li><li><a href="#" onclick="setPlaybackSpeed(1.25)">1.25‚®â</a></li><li><a href="#" onclick="setPlaybackSpeed(1.5)">1.5‚®â</a></li><li><a href="#" onclick="setPlaybackSpeed(1.75)">1.75‚®â</a></li><li><a href="#" onclick="setPlaybackSpeed(2)">2‚®â</a></li></ul></div>
<h3>Artisinal hand-crafted intro [00:00]</h3>
<ul>
<li>Our friends are <a href="https://adspthepodcast.com">all</a>
<a href="https://www.twoscomplement.org">starting</a> podcasts and they're better than
us at getting episodes out quickly :-)</li>
<li>It's been a while... let's say we're going for an artisinal hand-crafted vibe.</li>
<li>Only choice at this point is to claim we're going for quality over quantity... or something...</li>
<li>You can see <a href="https://en.wikipedia.org/wiki/Pipeline_stall">the bubbles</a> in
our hand-crafted episode designs so you can tell they're made with love.</li>
</ul>
<h3>Standard disclaimer [00:30]</h3>
<ul>
<li>Standard disclaimer: here to share our love of random systems and
systems-programming topics.</li>
<li>But we only know so much! Will try not to say things that are wrong.</li>
<li>Will followup with &quot;errata&quot; (corrections/clarifications) as we find out about
them and put them up on (this) website.</li>
<li>We do the &quot;lifelong learners&quot; thing, always trying to push the boundaries of
things we know about and have conversations about what's interesting to
develop and hone our understanding.</li>
</ul>
<h3>The &quot;silly&quot; interview question [00:55]</h3>
<ul>
<li><em>Bunch</em> of ideas for things to talk about...</li>
<li>Today we're going to go kind of a &quot;silly&quot; interview question.</li>
<li>We've heard people do ask this question!</li>
<li>Walk into the interview, interviewer says &quot;tell me what happens when you put
an address into the URL bar and hit enter... <strong>in as much detail as humanly
possible</strong>?!&quot;</li>
<li>Probably not going to cover a lot of things, we're shooting for ~1 hour,
<strong>everybody listening will know a bunch more than we do about these things</strong>,
so tweet <a href="https://twitter.com/tlbhit">@TLBHit</a> with more juicy details we can
note in the show notes or in a future episode.</li>
<li>Not going to start from Maxwell's equations / SPICE simulations of
transistors, gonna start a <em>little</em> higher than that.</li>
</ul>
<h3>Timeless questions [01:55]</h3>
<ul>
<li>Related story: when working on chipsets @cdleary had a buddy who would slam
motherboard down on the table, point at it, and ask the candidate to describe
how some aspect of it worked.</li>
<li>Not recommended, but fun concept, in the sense it's easy to lose yourself in
all the wonderful details of a modern machine.</li>
<li>Lots of complexity comes together to make these things happen (and some
complexity we got via the evolutionary process!).</li>
<li>What's great about modern computers is how much of it is actually possible to
understand and possibly even do yourself.</li>
<li>Projects doing <a href="https://github.com/cliffordwolf/picorv32">PicoSoCs</a> [using
entirely open source tooling!]</li>
<li><a href="https://en.wikipedia.org/wiki/QEMU">Open source software projects like QEMU</a> where you can create a
software emulation layer for an entire machine from scratch.</li>
<li>Things like
asm.js or <a href="https://github.com/WebAssembly/tool-conventions/issues/27">WebAssembly where you can create a familiar machine and operating
system experience in a
browser</a>, etc.</li>
<li>All the visibility of modern computing systems and the fact you <em>can</em>
understand everything down to nearly the transistors is, in a way, what's
beautiful about working in computers</li>
<li>But <em>just</em> as importantly you don't <em>need</em> to know it all to use them well --
we have these nice abstraction layers and you can keep diving down into the
layer that interests you and snowball-up more knowledge and capabilities as
you go.</li>
<li>This is really the power of abstraction!</li>
<li>So this interview question is well trodden in a sense and can apply to many
different fields, adapted to different areas.</li>
<li>Everybody has to deal in abstraction, one of the few fundamental human
faculties.</li>
<li><a href="https://iep.utm.edu/hume-ima/#SH3b">Hume had described a few different fundamental
ways</a> that humans come up with things
like imagination, abstraction, and such.</li>
<li>Related: <a href="https://www.youtube.com/watch?v=0fKBhvDjuy0">powers of ten video from
1977</a>: shows expanding scale
from a cell on somebody's hand up to the highest abstractions in the universe
and down the smallest ones all in one dialog/visualization. Fun and
enlightening!</li>
<li>Both abstraction and decomposing things into the smallest pieces you can both
fun ways to learn.</li>
</ul>
<h3>What was the question again? [04:15]</h3>
<ul>
<li>Back to the fun question for today!</li>
<li>What happens when you go to the browser's address bar, type &quot;https://tlbh.it&quot;
and then hit enter.</li>
<li>Have to start with the keypress, you pressed enter!</li>
<li>Out in physical world before physical I/O becomes digital I/O.</li>
<li>Some of us are familiar with this basic concepts from
<a href="https://en.wikipedia.org/wiki/Tron">Tron</a> (or <a href="https://en.wikipedia.org/wiki/Tron:_Legacy">Tron:
Legacy</a>, or its <a href="https://en.wikipedia.org/wiki/Tron:_Legacy_(soundtrack))">Draft Punk
soundtrack</a>, all of
which will be helpful.</li>
</ul>
<h3>Starting in physical IO space [04:50]</h3>
<ul>
<li>Keyboards! Fundamental component of computer I/O design e.g. for input of
text (still more popular than footpedals).</li>
<li>All also (conceptually) based on switches! Just like internals of computer
are based on switches -- took the idea and put them both inside the computer
but also underneath your fingertips.</li>
<li>Going to go with mechanical keyboards because they're enjoyable, make a
beautiful clacky noise.</li>
<li>Very classic keyboard was the <a href="https://youtu.be/D7wmMZmMinM?t=212">IBM Model M  keyboard</a>
(@cdleary had one of those!), had a &quot;buckling spring&quot; design -- buckling
caused switch to close.</li>
<li>Modern keyboards instead have <a href="https://youtu.be/vLGklanzQIc?t=59">a little plastic &quot;leaf&quot; that prevents
electrical connectivity</a>, when you move it
out of the way with your finger press electrical connectivity is established.
Switch action: on/off, controlled by your finger.</li>
<li>Keyboard has a little microcontroller inside of it, it's looking for things
that get pressed, usually done through a <a href="https://en.wikipedia.org/wiki/General-purpose_input/output">&quot;general purpose input/output pin&quot;
(GPIO)</a>.</li>
<li>Microcontrollers can look at voltages / whether things are connected to it in
order to ask &quot;is this a zero or a one right now&quot; via these GPIO pins. Some of
them are configured to read (to look for a 0 or 1 voltage level and say which
one is currently observed when it's sampled by the microcontroller).</li>
<li>Microcontroller reads these lines, then figures out what key (or set of keys)
are pressed based on the 1s and 0s lines for the GPIO input lines that are 1s
going to the microcontroller.</li>
<li>So in our case, it sees the row/column activated means that the &quot;enter&quot; key
is pressed (because that's what the row and column I see &quot;map to&quot; in its
firmware running on the microcontroller).</li>
</ul>
<h3>How can we relate this back to Tron though? [06:40]</h3>
<ul>
<li>This is the grid from Tron presumably? And the lightcycles will need to come
in to take us to the computer proper.</li>
<li>Gotta send stuff over to the computer!</li>
<li>In modern era USB devices talk this standard USB Human Interface Device (HID)
protocol that's layered on top of USB transactions.</li>
<li>What you do is send packets to a <em>standard driver</em> inside of your computer
that knows how to talk to these human interface devices.</li>
<li>Good we've standardized on at least how keyboards and mice tend to work at
this point in computer history. (Joysticks: let's not go there.)</li>
</ul>
<h3>Brief intro to USB [07:15]</h3>
<ul>
<li>USB is a neat, modern, minimal-number-of-wires protocol for peripherals
talking to computers.</li>
<li>What you do is wiggle these differential transmission lines -- in order to
get good signal integrity there's common ways to do these protocols for
things talking over wires to computers (differential transmission, NRZI &amp;
long-term-balanced balanced codings, etc).</li>
<li>You're able to wiggle these transmission lines at pretty high speeds these
days -- lots of work has gone into figuring out how to make the minimal
number of wires to go quickly when toggling between zeros and ones.</li>
<li>@cdleary only knows about low(/full/high) speed USB from a random project I
had worked on in the past, USB 3 may be interestingly different to achieve
such high speeds.</li>
<li>Serial engine that turns signals into packets and packets turn into
transactions, OSI-style model of different layers of the communication
protocol pieces.</li>
<li>Few different types of transfers in USB: keyboard firmware going to shove
scan code into interrupt transfer that goes to the host, and that goes out to
the host, on the wire (via the lightcycle :-)</li>
</ul>
<h3>Enter vs return? [08:30]</h3>
<ul>
<li>Is there a difference between enter and return? <code>^M</code> vs <code>^V</code> say? [ed: are &quot;return&quot; and &quot;enter&quot; keys meaningfully different?!]</li>
<li>Remapped keyboard for caps lock to be &quot;return&quot; (whereas my normal key is &quot;enter&quot;) and it seemed to do the same thing, so not sure where it makes a difference.</li>
<li>@jfbastien remaps caps lock to be escape, traditional vi vs emacs difference?</li>
<li>@cdleary couldn't figure out how to undo the mapping.</li>
<li>Classic interview question where answer is &quot;:q&quot;.</li>
</ul>
<h3>Into the chipset [09:05]</h3>
<ul>
<li>Now we're getting to the motherboard &quot;chipset&quot;: it's called a chipset because it's literally a set of chips, the little rectangles with the black epoxy and logos on top</li>
<li>There's a thing inside of your &quot;motherboard&quot; (big green Printed Circuit Board with all the chips on it inside of your computer)</li>
<li>Called the &quot;southbridge&quot;: talks to computer peripherals, things you're going to plug into your computer to interact with the CPU / core complex</li>
<li>You can see the term &quot;bridge&quot; here, it's &quot;bridging&quot; or turning other ways of communicating <em>into</em> something the CPU core complex understands more natively like PCIe reads and writes</li>
<li>One of the things that usually lives in the southbridge is a USB &quot;host controller&quot;</li>
<li>USB host controller is going to help talk to all the USB devices that you might plug into your computer</li>
<li>The USB host controller talks to the USB devices over the wires that are plugged in from USB on one &quot;side&quot;, and talks PCIe to the CPU on the other &quot;side&quot;, over memory writes/reads to addresses that get configured on boot: this is the part that interfaces with the CPU / core complex</li>
<li>The writes that get routed from the USB host controller towards the core complex may have to go through a device MMU, or IOMMU, which can prevent wild writes from devices to arbitrary physical memory locations -- notably this IOMMU can have a TLB for fast caching of address translation -- for places we write to frequently we'll likely get TLB hits!</li>
<li>Things like DMA (Direct Memory Access) can happen through the PCIe-side connections [where peripherals can dump things directly into the same address space observed by the CPU]</li>
<li>USB host controller is going to need to inform the CPU about the interrupt (with the keypress payload) that came in from the keyboard peripheral so it can handle it appropriately</li>
<li>Standard PCIe interrupts (e.g. MSI-X) are just little write packets that happen over an address space to a memory location</li>
<li>Those get serialized over the PCIe wires</li>
<li>Those get serviced in a (coalesced) interrupt handler inside of the CPU<ul>
<li>So I'll say &quot;hey CPU I have something that I need to tell you about / need you to do, I'm a peripheral&quot;</li>
<li>Then the kernel will come pick up that note (which has been written to a memory location) inside of the &quot;bottom half&quot; interrupt handler</li>
<li>Kernel breaks interrupt handling into two pieces: bottom half and top half</li>
<li>Bottom half just quickly tries to handle &quot;oh there's something here, let me make a note of that&quot;</li>
<li>Top half comes along and tries to actually do the work when there's time</li>
<li>Instead of keeping interrupts masked for a really long time will punt things to happen in the top half in a kernel process, so that's just a software architecture / terminology thing</li>
</ul>
</li>
<li>Ultimately events are pushed through file descriptors (in our particular case), as a record that indicates &quot;hey there's an event that happened on this input device of this type with this code and it had some value associated with it&quot; -- usually this data record is a &quot;triple&quot; for the input device drivers</li>
</ul>
<h3>Why are input events exposed through file descriptors? [12:00]</h3>
<ul>
<li>Why are events pushed as file descriptors?</li>
<li>A bit odd that when you put a key on the keyboard there's files involved <em>with your keyboard</em></li>
<li>Is it because everything in UNIX style is a file descriptor?</li>
<li>Guess it makes it easy to handle these types of functions like select/poll/epoll to have files, but why is it fundamentally?</li>
<li>Right, kernel is trying to expose everything in a uniform way</li>
<li>Could have just arbitrary memory locations that are changing that are accessible to programs in userspace</li>
<li>OR could use this already existing abstraction of a file to talk about things that have happened and then people can look at files</li>
<li>In Linux kernel example is something like SysFS are ways to askthe kernel about arbitrary properties like &quot;what is the connectivity of my devices&quot;</li>
<li>Lots of things riding on this filesystem abstraction concept</li>
</ul>
<p>[Note: for low latency communication between peripherals and userspace folks often do map registers from the device's PCIe memory space directly into userspace (as uncacheable memory) and have a protocol for interacting with the device so that you don't need to go through filesystem syscall overheads, folks are continuing to try to build reusable abstractions for this like <code>io_uring</code>.]</p>
<h3>Through the window manager to the browser-UI-owning process [~12:15]</h3>
<ul>
<li>In our particular case we'll notice the interrupt came from the keyboard device</li>
<li>We'll serve it up to the driver which will push that event over that file descriptor</li>
<li>Kernel produces a keycode</li>
<li>If you're running X11 / Xorg based window manager the X server is going to translate the keycode into a symbol (which is basically just a fancy keycode but at the X11 abstraction layer)</li>
<li>The X server will do a file descriptor event loop to look for these keycodes that are happening and push them to various windows which might be looking for what's happening with the keyboard</li>
<li>Thread that spins and waits for these notifications and then decides what to do when events come in</li>
<li>Like JF said, something like a select or an epoll would happen where you get woken up when a file descriptor it's watching gets updated</li>
<li>You see the input you notify the X client which is a window of some kind (in this case the browser window), it'll be informed that an enter has been pressed</li>
<li>So now that event that has been pushed to the browser window has to be handled by the browser process (which is the window-manager-connected application)</li>
<li>Browser has a &quot;thing&quot; (i.e. client handle) that connects to the window manager and it gets the event</li>
<li>Browser notices that the URL bar widget inside of the &quot;browser chrome&quot; -- which is the part of the browser that's not the content being displayed by a web page but that part that's wrapped around the content displayed by a web page -- is the thing that has focus</li>
<li>Fun fact! In Firefox the widgets were even implemented with a web-like technology called XUL that uses XML based widget descriptions and JavaScript event handlers</li>
<li>So <code>onKeyPress</code> event you'd use in a web page  is also generated for the URL bar widget</li>
<li>Reuse across content and chrome inside of the Firefox browser architecture</li>
<li>Similar things happen for native widget toolkits as well</li>
<li>This &quot;chrome&quot; is part of the root window for the process</li>
<li>But modern browsers have processes that manage groups of tabs for isolation
so things like crashes are not effecting all web pages running inside of the
project, that's been done through various initiatives like electrolysis in
Firefox.</li>
</ul>
<h3>Which parts of the browser might share a process? [~15:15]</h3>
<ul>
<li>Interesting: what parts of the browser are sharing across processes?</li>
<li><a href="https://www.usenix.org/conference/enigma2021/presentation/palmer">Chris Palmer presentation at
Enigma</a>
talking about how sandboxing works for Chrome.</li>
<li>One process for browser root, one for GPU process, bunch of separate
renderer, networking, storage processes.</li>
<li>Evolved over time which parts have their own process or not.</li>
<li>Sometimes will put things in the same process to save resources.</li>
<li>...thousands of tabs maybe, but don't want thousands of processes!</li>
<li>Interesting tradeoff that they do.</li>
</ul>
<h3>Inter-Process Communication patterns [16:20]</h3>
<ul>
<li>Classic question of how do you when you split things into processes, how do
you not pay the penalty; e.g. retain fast communication even though we
separated them into process isolated bits.</li>
<li>Interesting part of the design of a browser (or a general multi-process
application architecture!).</li>
<li>When you can have asynchrony you can have but but when you want fast
communication between processes how do you avoid getting slammed by context
switch overheads</li>
</ul>
<h3>The concept of &quot;chrome&quot; [16:55]</h3>
<ul>
<li>Funny/cute that Chrome is named after the part that's been minimized / that
you're not supposed to see!</li>
<li>Re: how to send messages from one process / window to another...</li>
<li>Depending on how the keypress notification is handled, may have one process
sending to another process, e.g. one displaying currently displayed tab.</li>
<li>Tell it to &quot;please navigate to the target URL because enter was pressed&quot;.</li>
<li>Cross-process messaging potentially, can be done in a bunch of ways!</li>
<li>Can use something like pipes, but in a lot of cases you want to use something
like shared memory.</li>
<li>Shared memory itself is really neat, and <em>not just</em> because it involves TLB
hits!</li>
<li>Also shared memory is an interesting way that two processes can share
physical pages at (potentially) different virtual addresses.</li>
<li>Interesting: shared memory is not something that C/C++ acknowledge really
exist in the machine model.</li>
<li>Same way in C/C++ before C++11, threads didn't exist in the abstract machine
model described by the language.</li>
<li>In <em>reality</em> they exist of course, but question of what's directly addressed
by language semantics / model.</li>
<li>The way it's modeled right now is it's basically addressed like external
modifications, so really ought to use volatile to do shared memory accesses.</li>
<li>Probably need a separate synchronization primitive, at least hypothetically,
to do cross-process locking say -- because needs different guarantees from
ones you get from threads which <em>do</em> live inside of the abstract machine
model.</li>
</ul>
<h3>Tabs and back/forward cache [19:20]</h3>
<ul>
<li>One thing about tabs, they have a navigation cache for going backwards and
forwards.</li>
<li>When we're updating the location -- say we're starting on a blank tab, which
are their own entity in the browser universe, they may take you to a special
display page or similar.</li>
<li>Then when you navigate it away to a particular website (like tlbh.it) then if
you hit the back button it may take you back to the blank tab page or where
you were before the navigation happened.</li>
<li>What's funny is apparently one of the most complicated pages in the whole
browser is about:blank -- weirdly complicated for some reason?!</li>
</ul>
<h3>What's in a URL? [20:10]</h3>
<ul>
<li>Out of the whole keyboard realm, got the keys that were pressed, and we've
got a URL -- the tab's content-frame-thingy is trying to navigate to the URL.</li>
<li>First thing we need to do is parse the URL that the user wrote.</li>
<li>Perhaps surprising that URL parsing ain't easy!</li>
<li>First thing you do is look at the protocol if one is specified; e.g. if you
wrote <code>https://</code>. If you didn't the browser usually infers a protocol.</li>
<li>Depending on the protocol has different ways of parsing things; <code>file://</code> and
<code>gopher://</code> and whatever else.</li>
<li>We're going to focus on the <code>http[s]://</code>, others have similar inner workings.</li>
<li>The way http-like ones work you kind of parse them inside-out...</li>
<li>There's a bunch of weird things in the URL; where's the Top Level Domain
(TLD)? Where's the domain? Where's the subdomains? This is going in
<em>leftwards</em> into the URL, assuming left-to-right text is being used.</li>
<li>On the left of <em>that</em> might have a username and a password inside the URL...</li>
<li>After the TLD might have a port, might have a slash with a path, then query
parameters, then query fragments.</li>
<li>All adds up to: URL parsing itself is really tricky!</li>
<li>Guess things like <code>file://</code> is more of a pseudo-protocol than a real
protocol, need to handle things like backslashes and such on Windows for
example vs in a web URL.</li>
<li><em>Don't</em> want to just take the file path and hand it to the OS -- there are
some paths in the OS itself that are special; in the early days of Chrome
some undocumented things in the guts of Windows that, if not filtered out,
could be the source of exploits (e.g. some special device thing).</li>
</ul>
<h3>Working at places and not knowing everything [22:40]</h3>
<ul>
<li>Funny to work for a browser company (Mozilla in @cdleary's case) but mostly
because of working on the JS engine learn things as they pertain to that one
part that @cdleary had worked on.</li>
<li>Learn maybe about some of the interfacing parts, like how DOM nodes get
reflected into JS objects or how interop with the browser-level cycle
collector is supposed to do.</li>
<li>Similar working for a GPU company where you're primarily working on CPU
oriented things, still probably can't adequately describe how the rendering
pipeline for a GPU.</li>
<li>Everybody has these interesting blind spots that can be counterintuive given
their work experience, where everybody is going through the <a href="https://xkcd.com/1053/">xkcd &quot;mentos and
coke: you're one of the lucky 10,000 people to be learning this fact
today&quot;</a> experiences over and over again...</li>
<li>Notion that Isaac Newton was perhaps the last person to know all of human
knowledge at one time.</li>
<li>Who was even the last person to know all of CS?</li>
<li>Kind of winging this interview question so far, not sure how interviewer
would feel about our answer...</li>
<li>Our hypothetical interviewer could ask about subtleties in distinctions like
&quot;what's the difference between Universal Resource Locator (URL) and Universal
Resource Indicator (URI)&quot;, and maybe nobody knows? Maybe was important to
know the distinction 20 years ago? Everybody tends to say URL, and some
people say URI just to nerd-snipe each other. We'll just ignore some of these
perhaps lower-order-bit distinctions.</li>
<li>We'll just assume we're doing well on the interview and keep going on.</li>
<li>Benefit of doing our own podcast is we pretty much have to be here no matter
how badly we do on the interview question.</li>
</ul>
<h3>Domain name to IP resolution [24:40]</h3>
<ul>
<li>Now that we've parsed the URL we have the TLD, the domain, the subdomains
(none in our particular case).</li>
<li>Going to ignore the rest of the request for now, how do we talk to that server?</li>
<li>Have to figure out how to talk to the server that name corresponds to?</li>
<li>Resolve via DNS (Domain Name Service) resolution</li>
<li><code>.it</code> is the top level domain, do we have to go to Italy? Not quite how it works...</li>
<li>There's DNS servers that just map all of the domains to IP address and such</li>
<li>They do more than IP addresses but by and large this is what we care about here</li>
<li>What's interesting: DNS resolution is notoriously totally insecure! Done in the clear, uses UDP packets</li>
<li>Going to need to craft and send out a packet here (haven't talked about packets yet)</li>
<li>Bunch of things on top of this basic concept: recently Firefox rolled out DNS
resolution over https, used CloudFlare to do resolution</li>
</ul>
<h3>Stacks of trust and probabilistic data structures [26:15]</h3>
<ul>
<li>All stacks of trust right? Between &quot;trust no one ideal&quot; where you would only
have to trust yourself how do you stack things on top and keep everything
copacetic.</li>
<li>Not just roots of trust all the way down also caches all the way down (as we
know cache invalidation is hard!).</li>
<li>First thing browser does before it reaches out, asks whether it had looked up
the domain name before.</li>
<li>When it hasn't looked up the domain name before asks, &quot;Is this URL a known
malicious website?&quot;</li>
<li>Has a list of websites you just don't want to go to, will suggest that it
looks malicious.</li>
<li>Something called Google Safe Browsing inside of Chrome that's also used by
other browsers.</li>
<li>There's a <em>lot</em> of websites and the list changes pretty frequently</li>
<li>Instead of local browser having full list of all malicious sites...</li>
<li>Google fun-interview-tip is to read up on bloom filters. ;-)</li>
<li>Originally implementation of safe browsing used bloom filters:<ul>
<li>You ask whether domain is safe, it will either say &quot;yes&quot; or &quot;I'm not sure&quot;.</li>
<li>When &quot;not sure&quot; asks a separate server with the full list (Google central
server) whether it is or in.</li>
</ul>
</li>
<li>When your browser already has it cached doesn't have to do that extra round
trip.</li>
<li>WebKit a few weeks ago noted they were going to start <a href="https://the8-bit.com/apple-proxies-google-safe-browsing-privacy/">proxying safe-browsing
requests through a separate server, led to a lot of
discussion</a>.</li>
<li>Interesting things to talk about in this space of how the caches work and how
to properly check certain properties.</li>
</ul>
<h3>Protocol changes/upgrade [28:45]</h3>
<ul>
<li>We were talking about how to parse a given protocol's URL, but there's also
the idea of protocol <em>changes</em> when you look up the URL.</li>
<li>Thing called HSTS which can <em>change</em> an HTTP request to an HTTPS request.
&quot;Upgrade&quot; you from an insecure in-the-clear to a secure connection.</li>
<li>One way this is done is called HSTS Preload: all the HTTP-to-HTTPS domains
are pre-loaded into the browser. Browser just has a list of all the domains
that have said &quot;I am HTTPS only!&quot;</li>
<li>What's interesting there is that the domain owners tell the browser vendors
to always do HTTPS connections for them.</li>
<li>e.g. google.com would refuse to connect to your browser without using HTTPS.</li>
<li>Not google.com-only that can do that, not just a given domain, can have
entire TLDs opted in; e.g. a <code>.dev</code> or a <code>.google</code> TLD is opted in to have
HTTPS-only for not only themselves but all subdomains.</li>
<li>If you reserve a <code>.dev</code> domain (under the <code>.dev</code> TLD) then you have to have
HTTPS.</li>
<li>If you don't have the capability of doing only-HSTS-Preload there's a thing
called HTTP headers: once client connects to you can respond with a bunch of
headers, one of which is &quot;Strict Transport Security&quot;.</li>
<li>If you reply with that header it says &quot;next time you talk to me, do HTTPS!&quot;</li>
</ul>
<h3>Building security in, bolting it on, the space inbetween [30:30]</h3>
<ul>
<li>It's a big stack of caches! These things are in the browser's cache, some of
them have timers that expire after a while.</li>
<li>Super complex because the internet is large, and security/privacy weren't
really built into the Internet from the beginning. Origins as a researchy
military project thing. Not well understood what security and privacy
actually would mean at the time.</li>
<li>Main desiderata was, we think, &quot;if a nuke hits the Internet it continues
routing packets to the desired endpoints&quot;?!</li>
<li>Because security features were surprising to the designers, weren't built in
from the beginning -- even now, we look back and say &quot;well the Internet
should have been designed differently!&quot;, even now, as these things are
designed we add security layers that themselves can have privacy holes.</li>
<li>Things like <strong>supercookies</strong>, which use some of the caches and preloadings to
create not a <em>traditional</em> cookie (where you browser stores some information
as requested by a website), but supercookies could allow external entities to
infer that you've talked to this client before.</li>
<li>Can, say, measure latency or figure out &quot;did you talk to me over HTTP or
HTTPS this time around&quot;. If you reserve a certain number of subdomains and do
HSTS or things like this, you can potentially make these supercookies.</li>
<li>Security built on top of a nominally originally-insecure system and
privacy-insensitive system, trying to fit those properties back into the
system tend to not-always work out the way it was intended.</li>
<li>Kind of cute... there's a lot of weird, odd things on the Internet that
weren't necessarily designed a priori but rather evolved over time.</li>
<li>[Supercookies] sound delicious, but are emblematic of trying to introduce a
mechanism into a complex system and try to see all the use cases that can
possibly arise for it.</li>
</ul>
<h3>Surprisingly nuanced: unicode domains [32:30]</h3>
<ul>
<li>Similarly you'd think, &quot;Hey I want more than english speakers to be able
to use the internet -- can we support unicode in domain names?&quot;</li>
<li>We talked about parsing a URL being difficult and that was perhaps using a mental model that URL is ASCII, but it's not!</li>
<li>Nowadays the ways URLs work, they support unicode. Very different between
TLDs. Up to TLDs to decide what subset of unicode they support. But unicode
itself is quite complicated.</li>
<li>For example, whole topic of canonicalization of unicode: for JF's name,
there's a C-cedilla. Can write as <code>&lt;c&gt; &lt;combining-character&gt; &lt;cedilla&gt;</code> or
as the <code>&lt;c-cedilla&gt;</code> character.</li>
<li>There's also multiple ways to <em>canonicalize</em> unicode.</li>
<li>So if you have two domain names that look <em>visually</em> exactly the same, but
they are actually different characters, are they the same domain?</li>
<li>To a user it seems like it kind of ought to be, but to a computer it's not.</li>
<li>Very tricky to figure out whether two strings are &quot;the same&quot; for the
definition of &quot;the same&quot; we're interested in here.</li>
<li>From user perspective it might be obviously whether they're the same, but
from a program perspective it's difficult.</li>
<li>Something called &quot;punycode&quot; which is used to encode URLs in ASCII deriving
from the unicode equivalent of their encoding.</li>
<li>For example domain with cyrillic characters some of them might look exactly
the same as ASCII characters. Could make something that looks like google.com
or yourbankname.com but with cyrillic characters and in those cases they
would be confusable.</li>
<li>We don't want that to be possible, browsers have heuristics to try to prevent
confusable URLs from being displayed.</li>
<li>Unicode consortium has whole technical report on this, called <a href="http://unicode.org/reports/tr36/">Technical
Report 36 on unicode security
considerations</a>.</li>
<li>Maybe if there was a secure connection there would be a secure connection
registrar telling you whether a domain looks too much like some other domain.</li>
<li>Even what is secure is hard to explain to users. &quot;There's a lock on there,
what does it even mean?&quot;</li>
<li><a href="https://twitter.com/__apf__/status/634858452309831680">Adrienne Porter Felt (of Google Chrome) noted her sister asked her what the
handbag sign was</a>, and
she realized she was referring to the lock icon.</li>
<li>Even the fact there's a lock: how discoverable are these properties? For
people who are not technical exposing security in a way that makes sense (via
education, UI / discoverability, etc).</li>
<li>To some extent security and convenience are often in tension: &quot;Wait, it might
be insecure, click through these three different things to pass!&quot; If things
are <em>supposed</em> to be working it's quite an inconvenience, but it's worth it
to indicate to people &quot;this may not be what you're trying to do, this might be
something very bad happening&quot;.</li>
<li>As tech professionals we can see places we've trained users to click through
like, &quot;Yeah, ok whatever, let me through&quot;. Hard to train users not to click
&quot;yes&quot; on everything!</li>
<li>Funny is IE6 or maybe IE5 when you used the browser and you used
an HTTP connection it'd pop up a dialog that said &quot;your connection is secure&quot;
and you had to click the OK button or a more info button. Reverse of what you
have nowadays! Used to have an <em>alert</em> when the connection was secure.</li>
<li>Things have surely evolved over the last 20-25 years.</li>
<li>Constantly evolving and growing ecosystem as considerations arise.</li>
</ul>
<h3>Back to the question: UDP sockets for DNS [37:40]</h3>
<ul>
<li>Maybe you've tried out socket programming before.</li>
<li>Open a &quot;socket&quot; which is a connection that lets you leave the machine via the
network. Can do IP level, TCP level connection, all possibilities when we're
doing this socket level programming.</li>
<li>Sockets look like file descriptors (piggybacking more on this abstraction of
files and file descriptors).</li>
<li>Create a UDP connection -- a &quot;connectionless connection&quot; [or connectionless
socket, is maybe less confusing to say], not a persistent connection, just
throwing the packets against some potential endpoint.</li>
<li>Then we talk to our DNS resolution endpoint: &quot;Hey I have this text here
<code>tlbh.it</code>, I need to figure out what internet address this corresponds to.&quot;</li>
<li>Maybe browser knows about TLD inherently so just need to figure out the
second part...</li>
<li>This is about where we're at!</li>
</ul>
<h3>Establishing HTTPS after name resolution [38:45]</h3>
<ul>
<li>We're doing HTTPS so it has to be secure, and we're got to use some
encryption scheme to talk to the endpoint, to do the HTTP request.</li>
<li>Have to talk about &quot;crypto&quot;: unfortunately nothing to do with cryptocurrency,
cryptology, cryptnomicon, game stop, or whatever else. We mean cryptography
here.</li>
<li>Generally the browser is going to talk to the server through Transport
Layer Security (TLS).</li>
<li>Start with a handshake where the browser and server negotiate how to crypto
at each other. Server then gives certificate back, browser checks certificate
is legitimate, using a root store of certificates (signed by Certificate
Authorities). Someone trusted by the OS signed off on the server's certificate
so the browser trusts it.</li>
<li>Fancy math that's easy to verify in one direction but very hard or
effectively impossible to reverse.</li>
<li>Once trust is established between those two the browser users the server's
<em>public</em> key, which is <em>asymmetric</em> encryption to establish a session key,
which is a <em>symmetric</em> key, to communicate with less overhead going forward.</li>
<li>Provides reliability on top of the transport: get a packet, decrypt the data,
and if there was a random bit flip you would fail to authenticate the packet
itself. Prevents people from tampering but also nature from tampering with
random bit flips or what have you.</li>
<li>Some of the math in there known to be pretty secure for now, probably secure
for next 15-20 years. Some of the math also known to be super insecure by
now -- if you look back at the <em>old</em> protocols some of them are known to be
broken. Super tricky to do properly and lots of corner cases.</li>
<li>General idea is to use fancy math [and a trust network] to determine &quot;how can
I trust this person is who they say they are&quot;.</li>
<li>Layer of trust that has been created over time.</li>
</ul>
<h3>Accelerated primitives on modern HW [41:35]</h3>
<ul>
<li>We use crypto all the tim in browsers as well as other places.</li>
<li>A lot of the primitive operations are accelerated by modern hardware.</li>
<li>Same way we talk about TLB hits there's also these crypto acceleration
facilities inside of the CPU.</li>
<li>Crypto by and large tends to shuffle bits around a bunch, do it in a bunch of rounds, do some math with it.</li>
<li>Things like AES, one round of AES might be accelerated by a CPU and you call that instruction back to back.</li>
<li>Instructions have been added to CPUs in the past bunch of years to do things
like AES or CRC32C to checksum data in ethernet packets.</li>
<li>CPU and network protocol co-evolution going on here!</li>
<li>Even things like randomness, things that grab entropy from CPU's thermals and
uses that as its entropy pool, expose it as an instruction.</li>
<li>Randomness in a CPU also one of those frought-with-peril things where it
sounds good but how do you verify it's actually random, doesn't have a bias
or anything else, hasn't been tampered with, lots of tricky stuff.</li>
</ul>
<h3>A little sumpthin server-side [47:25]</h3>
<ul>
<li>Now we have the server looking at the path that was requested.</li>
<li>Eventually the request -- the HTTP GET request -- arrived for the base URL of our
website (the content at <code>/</code>).</li>
<li>Server gets that request, sees its HTTPS, tries to figure out what it's
supposed to do in order to serve up this request, for whatever the base page
is.</li>
<li>If you've tried to write web servers, perhaps using a web server <em>framework</em>,
what you'll do is configure <em>routes</em>, those routes will cause certain things
to happen within the server process to serve that request on that particular
path.</li>
<li>If I did <code>/foo</code> I might invoke a <code>FooHandler</code> that kicks in as a function
that serves the connection that was made from this client.</li>
<li>Beyond that you can do things like keep persistent connections and things
like this, but basic query-response model is HTTP GET which has a complete
response with a data payload.</li>
<li>Responses also have status codes, you'll be familiar with HTTP 404. :-)<ul>
<li>Informational responses: 100-199</li>
<li>Successful responses: 200-299</li>
<li>Redirects: 300-399</li>
<li>Client errors: 400-499</li>
<li>Server errors: 500-599</li>
</ul>
</li>
<li>JF's personal favorite, HTTP 418 &quot;I'm a teapot&quot;.</li>
</ul>
<h3>Signoff [56:10]</h3>
<ul>
<li>Took a while to record this &quot;episode 2&quot;, hope we take less time to record the next one</li>
<li>If people have questions/answers/comments / things they want us to talk about
/ errata to suggest hit us up on <a href="https://twitter.com/TLBhit">Twitter @TLBHit</a>.</li>
<li>We don't know how email works</li>
<li>Whole nother episode, how does email work</li>
<li>Every program has to grow until it does email</li>
</ul>
<h3>Sideband References</h3>
<ul>
<li><a href="https://magcius.github.io/xplain/article/window-tree.html">X Window System Advanced Window Techniques</a> describes how input is delivered.</li>
<li><a href="https://unix.stackexchange.com/questions/143757/linux-kernel-dropping-custom-keyboard-scan-codes">Example of the kernel seeing weird scan codes and dropping them</a></li>
<li><a href="https://unix.stackexchange.com/questions/63688/what-happens-when-ctrl-alt-fnum-is-pressed/63700#63700">Brief walkthrough to keyboard.c in the Linux kernel</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/input/input.txt">Linux's &quot;input drivers&quot; documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evdev">evdev for input device events</a></li>
<li>Some good discussion on <a href="https://forums.tomshardware.com/threads/questions-regarding-the-pcie-root-complex-pcie-lanes-and-the-pch.2115479/">southbridge to CPU core / DRAM traversal</a></li>
</ul>
    </main>
    <script>const setPlaybackSpeed = speed => { [].slice.call(document.querySelectorAll('audio,video')).map((e, idx) => { e.playbackRate = speed; }); }</script>
  </body>
</html>
